(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{228:function(e,t,a){"use strict";a.r(t);var n=a(6),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"arrays-example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arrays-example"}},[e._v("#")]),e._v(" Arrays example")]),e._v(" "),a("p",[e._v("Shows how to exchange and work with arrays either created in WebAssembly or in JavaScript.")]),e._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),a("ul",[a("li",[e._v("Using the loader and the full runtime to work with managed objects.")]),e._v(" "),a("li",[e._v("Creating arrays in WebAssembly and using them in JavaScript.")]),e._v(" "),a("li",[e._v("Creating arrays in JavaScript and using them in WebAssembly.")]),e._v(" "),a("li",[e._v("Using both copies of and live views on arrays.")]),e._v(" "),a("li",[e._v("Performing "),a("code",[e._v("unchecked")]),e._v(" accesses where the length of an array is known.")]),e._v(" "),a("li",[e._v("Pinning objects externally to prevent premature garbage collection.")])]),e._v(" "),a("h2",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example")]),e._v(" "),a("div",{staticClass:"language-editor extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("#!optimize=speed&runtime=default&exportRuntime\n/** Creates a new array and returns it to JavaScript. */\nexport function createArray(length: i32): Int32Array {\n  return new Int32Array(length)\n}\n\n/** Randomizes the specified array's values. */\nexport function randomizeArray(arr: Int32Array): void {\n  for (let i = 0, k = arr.length; i < k; ++i) {\n    let value = i32((Math.random() * 2.0 - 1.0) * i32.MAX_VALUE)\n    unchecked(arr[i] = value)\n  }\n}\n\n/** Computes the sum of an array's values and returns the sum to JavaScript. */\nexport function sumArray(arr: Int32Array): i32 {\n  let total = 0\n  for (let i = 0, k = arr.length; i < k; ++i) {\n    total += unchecked(arr[i])\n  }\n  return total\n}\n\n// We'll need the unique Int32Array id when allocating one in JavaScript\nexport const Int32Array_ID = idof<Int32Array>()\n\n#!html\n<textarea id=\"output\" style=\"width: 100%; height: 100%\" readonly></textarea>\n<script>\nloader.instantiate(module_wasm).then(({ exports }) => {\n  const output = document.getElementById('output')\n\n  /** Logs a message to the textarea. */\n  function log(message = '') {\n    output.value += `${message}\\n`\n  }\n\n  // A simple example using an array created in WebAssembly.\n  function example1() {\n    log('=== Example1 ===')\n\n    // Obtain the necessary runtime helpers\n    const { __pin, __unpin, __getArray } = exports\n\n    // Create a new array in WebAssembly and get a reference to it. Note that\n    // the array is not reachable from within WebAssembly, only externally, so\n    // we should pin it to prevent it from becoming garbage collected too early.\n    let arrayPtr = __pin(exports.createArray(5))\n    log(`Array pointer: ${arrayPtr}`)\n\n    // Log its elements to make sure these are zero\n    log('Initial values: ' + __getArray(arrayPtr).join(', '))\n\n    // Randomize the array in WebAssembly and log it again\n    exports.randomizeArray(arrayPtr)\n    log('Randomized values: ' + __getArray(arrayPtr).join(', '))\n\n    // Compute the array values' sum and log it. This will overflow i32 range.\n    let total = exports.sumArray(arrayPtr)\n    log(`Sum (likely overflown): ${total}`)\n\n    // We are done with the array, so __unpin it so it can become collected.\n    __unpin(arrayPtr)\n\n    log()\n  }\n  example1()\n\n  // A slightly more advanced example allocating the array in JavaScript instead\n  // of WebAssembly, and utilizing a live view to modify it in WebAssembly memory.\n  function example2() {\n    log('=== Example2 ===')\n\n    // Obtain the necessary runtime helpers\n    const { __pin, __unpin, __newArray, __getArray, __getArrayView } = exports\n\n    // Create a new array, but this time in JavaScript. Note that the array is\n    // again not reachable from within WebAssembly, only externally, so we\n    // should pin it to prevent it from becoming garbage collected too early.\n    let arrayPtr = __pin(__newArray(exports.Int32Array_ID, [\n      3, 4, 5, 6, 7, 8, 9\n    ]))\n    log('Array pointer: ' + arrayPtr)\n\n    // Log its elements to make sure these are the provided values\n    log('Initial values: ' + __getArray(arrayPtr).join(', '))\n\n    // Compute the array values' sum and log it\n    let total = exports.sumArray(arrayPtr)\n    log('Sum: ' + total)\n\n    // Instead of copying, let's obtain a live view on the array and modify its\n    // values right in WebAssembly memory.\n    let view = __getArrayView(arrayPtr)\n    view.reverse()\n\n    // Log the array's elements, now reversed\n    log('Reversed values: ' + __getArray(arrayPtr).join(', '))\n\n    // We are done with the array, so __unpin it so it can become collected.\n    __unpin(arrayPtr)\n\n    log()\n  }\n  example2()\n})\n<\/script>\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("NOTE")]),e._v(" "),a("p",[e._v("This example utilizes the loader to work with managed objects, hence requires "),a("code",[e._v("--exportRuntime")]),e._v(" to be set to expose the runtime helpers to JavaScript.")])]),e._v(" "),a("h2",{attrs:{id:"resources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resources"}},[e._v("#")]),e._v(" Resources")]),e._v(" "),a("p",[e._v("Further information on using the loader and the runtime helpers is available as part of the "),a("RouterLink",{attrs:{to:"/loader.html#counting-references"}},[e._v("loader's")]),e._v(" and the "),a("RouterLink",{attrs:{to:"/garbage-collection.html"}},[e._v("garbage collection documentation")]),e._v(".")],1)])}),[],!1,null,null,null);t.default=r.exports}}]);